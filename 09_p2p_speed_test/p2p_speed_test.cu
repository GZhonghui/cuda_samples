// Generated by AI

#include <cuda_runtime.h>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <string>
#include <iostream>
#include <iomanip>
#include <sstream>

/*
 * CUDA P2P Bandwidth Matrix
 * -------------------------
 * Measures unidirectional peer-to-peer copy bandwidth (GB/s) between all
 * GPU pairs in the system using cudaMemcpyPeerAsync.
 *
 * Usage:
 *   ./p2p_bw [bytes] [iters] [warmup]
 *     bytes  - message size per copy (default: 64 << 20 = 64MB)
 *     iters  - timed iterations (default: 20)
 *     warmup - warmup iterations before timing (default: 5)
 *
 * Notes:
 *  - If P2P access is not supported between a pair, the test is skipped and
 *    reported as "--".
 *  - Peer access is enabled in both directions for each supported pair.
 *  - Timing uses CUDA events on the *destination* device.
 *  - Reported bandwidth = (bytes * iters) / elapsed_time_sec / 1e9.
 *  - All allocations are device memory; no host staging.
 */

#define CHECK(call) do { \
    cudaError_t _e = (call); \
    if (_e != cudaSuccess) { \
        fprintf(stderr, "CUDA error %s@%d: %s\n", __FILE__, __LINE__, cudaGetErrorString(_e)); \
        std::exit(EXIT_FAILURE); \
    } \
} while (0)

struct DeviceBuffers {
    void* dptr = nullptr;
    size_t bytes = 0;
};

int main(int argc, char** argv) {
    size_t bytes = 64ull << 20; // 64MB default
    int iters = 20;
    int warmup = 5;
    if (argc > 1) bytes = std::strtoull(argv[1], nullptr, 0);
    if (argc > 2) iters = std::atoi(argv[2]);
    if (argc > 3) warmup = std::atoi(argv[3]);

    int devCount = 0;
    CHECK(cudaGetDeviceCount(&devCount));
    if (devCount < 2) {
        std::cout << "Need at least 2 GPUs." << std::endl;
        return 0;
    }

    std::cout << "GPU Count: " << devCount << "\n";
    for (int i = 0; i < devCount; ++i) {
        cudaDeviceProp p; CHECK(cudaGetDeviceProperties(&p, i));
        std::cout << i << ": " << p.name << std::endl;
    }

    // Build canAccess matrix & enable P2P where possible.
    std::vector<std::vector<int>> can(devCount, std::vector<int>(devCount, 0));
    for (int i = 0; i < devCount; ++i) {
        for (int j = 0; j < devCount; ++j) {
            if (i == j) { can[i][j] = 0; continue; }
            int res = 0; CHECK(cudaDeviceCanAccessPeer(&res, i, j));
            can[i][j] = res;
            if (res) {
                CHECK(cudaSetDevice(i));
                cudaError_t perr = cudaDeviceEnablePeerAccess(j, 0);
                if (perr == cudaErrorPeerAccessAlreadyEnabled) {
                    cudaGetLastError(); // clear sticky err
                } else if (perr != cudaSuccess) {
                    fprintf(stderr, "Warning: cudaDeviceEnablePeerAccess(%d,%d) failed: %s\n", i, j, cudaGetErrorString(perr));
                    can[i][j] = 0; // disable test for this pair
                }
            }
        }
    }
    CHECK(cudaSetDevice(0)); // reset current device

    // Allocate one buffer per device (source & dest share same size).
    std::vector<DeviceBuffers> bufs(devCount);
    for (int d = 0; d < devCount; ++d) {
        CHECK(cudaSetDevice(d));
        CHECK(cudaMalloc(&bufs[d].dptr, bytes));
        bufs[d].bytes = bytes;
        // Fill with some pattern (optional)
        CHECK(cudaMemset(bufs[d].dptr, d, bytes));
    }

    // Pre-create one stream per device for timing convenience.
    std::vector<cudaStream_t> streams(devCount, nullptr);
    for (int d = 0; d < devCount; ++d) {
        CHECK(cudaSetDevice(d));
        CHECK(cudaStreamCreate(&streams[d]));
    }

    // Bandwidth matrix (GB/s)
    std::vector<std::vector<double>> bw(devCount, std::vector<double>(devCount, 0.0));

    for (int dst = 0; dst < devCount; ++dst) {
        for (int src = 0; src < devCount; ++src) {
            if (src == dst) {
                // local DtoD bandwidth (optional). We'll measure too.
                CHECK(cudaSetDevice(dst));
                auto s = streams[dst];
                cudaEvent_t start, stop; CHECK(cudaEventCreate(&start)); CHECK(cudaEventCreate(&stop));
                // warmup
                for (int w = 0; w < warmup; ++w) {
                    CHECK(cudaMemcpyAsync(bufs[dst].dptr, bufs[dst].dptr, bytes, cudaMemcpyDeviceToDevice, s));
                }
                CHECK(cudaEventRecord(start, s));
                for (int it = 0; it < iters; ++it) {
                    CHECK(cudaMemcpyAsync(bufs[dst].dptr, bufs[dst].dptr, bytes, cudaMemcpyDeviceToDevice, s));
                }
                CHECK(cudaEventRecord(stop, s));
                CHECK(cudaEventSynchronize(stop));
                float ms = 0.f; CHECK(cudaEventElapsedTime(&ms, start, stop));
                double sec = ms / 1e3;
                double gbps = ((double)bytes * (double)iters) / sec / 1e9;
                bw[dst][src] = gbps;
                CHECK(cudaEventDestroy(start)); CHECK(cudaEventDestroy(stop));
            } else if (!can[src][dst]) {
                bw[dst][src] = -1.0; // no P2P
            } else {
                // P2P copy src->dst
                CHECK(cudaSetDevice(dst));
                auto s = streams[dst];
                cudaEvent_t start, stop; CHECK(cudaEventCreate(&start)); CHECK(cudaEventCreate(&stop));
                // warmup
                for (int w = 0; w < warmup; ++w) {
                    CHECK(cudaMemcpyPeerAsync(bufs[dst].dptr, dst, bufs[src].dptr, src, bytes, s));
                }
                CHECK(cudaEventRecord(start, s));
                for (int it = 0; it < iters; ++it) {
                    CHECK(cudaMemcpyPeerAsync(bufs[dst].dptr, dst, bufs[src].dptr, src, bytes, s));
                }
                CHECK(cudaEventRecord(stop, s));
                CHECK(cudaEventSynchronize(stop));
                float ms = 0.f; CHECK(cudaEventElapsedTime(&ms, start, stop));
                double sec = ms / 1e3;
                double gbps = ((double)bytes * (double)iters) / sec / 1e9;
                bw[dst][src] = gbps;
                CHECK(cudaEventDestroy(start)); CHECK(cudaEventDestroy(stop));
            }
        }
    }

    // Cleanup resources before printing? We'll print first; cleanup after.

    // Print matrix header
    std::cout << "\nMessage size: " << bytes << " bytes, iters: " << iters << ", warmup: " << warmup << "\n";
    std::cout.setf(std::ios::fixed); std::cout << std::setprecision(2);

    // First row header: src devices
    std::cout << std::setw(5) << "dst\\src";
    for (int src = 0; src < devCount; ++src) {
        std::ostringstream oss; oss << src;
        std::cout << std::setw(10) << oss.str();
    }
    std::cout << "\n";

    for (int dst = 0; dst < devCount; ++dst) {
        std::ostringstream oss; oss << dst;
        std::cout << std::setw(5) << oss.str();
        for (int src = 0; src < devCount; ++src) {
            double val = bw[dst][src];
            if (src == dst) {
                std::cout << std::setw(10) << val;
            } else if (val < 0.0) {
                std::cout << std::setw(10) << "--";
            } else {
                std::cout << std::setw(10) << val;
            }
        }
        std::cout << "\n";
    }

    // Also print P2P accessibility matrix (optional)
    std::cout << "\nP2P Access (1=yes,0=no):\n    ";
    for (int j = 0; j < devCount; ++j) std::cout << j << " ";
    std::cout << "\n";
    for (int i = 0; i < devCount; ++i) {
        std::cout << i << ": ";
        for (int j = 0; j < devCount; ++j) {
            if (i == j) std::cout << "# ";
            else std::cout << can[i][j] << " ";
        }
        std::cout << "\n";
    }

    // Cleanup
    for (int d = 0; d < devCount; ++d) {
        CHECK(cudaSetDevice(d));
        if (streams[d]) CHECK(cudaStreamDestroy(streams[d]));
        if (bufs[d].dptr) CHECK(cudaFree(bufs[d].dptr));
    }

    return 0;
}
